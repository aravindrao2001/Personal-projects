# -*- coding: utf-8 -*-
"""assignment2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12vQAZ00KkV6ZJd1IQFtHFGxtZd2PXK8F
"""

import pandas as pd
food_trucks = pd.read_csv('food_trucks.csv')

food_trucks.head(5)

# Drop the 'vendorID' column from the DataFrame
ven= food_trucks.drop('vendorID', axis=1)

print(ven.head)

"""*In summary, VendorID cannot be used in clustering models because it is a categorical variable that does not provide meaningful information on the similarity between vendors. Clustering models use numerical values to measure similarity, and categorical variables cannot be used in Euclidean distance calculations that are typically used in clustering algorithms. Therefore, numerical attributes like Sales and Profit should be used to group similar vendors together in a clustering model.*

*Can be explained with an example ,We can represent vendors as points in a two-dimensional space, with Sales as the x-coordinate and Profit as the y-coordinate. We can use Euclidean distance to calculate the distance between any two vendors in this space. However, including VendorID as a third attribute in our calculations would not provide any meaningful information about the similarity or dissimilarity of vendors, and may even introduce noise or confusion into the model. Therefore, we should focus on numerical attributes like Sales and Profit that can be used to calculate distance and group similar vendors together.*
"""

#B (describe function )

food_trucks.describe()

"""*The describe() function in Python is a useful tool for any analyst working with a dataset. It provides a summary of basic statistical measures for each column in the dataset, such as the minimum and maximum values, mean, standard deviation, and quartiles. This information can be used to quickly gain insights into the range, spread, and distribution of the data. Additionally, the count provided for each column can help identify missing values or other data quality issues that may need to be addressed before proceeding with further analysis. By using the describe() function, an analyst can quickly gain a sense of the overall structure and characteristics of a dataset, which is valuable when building models or conducting other data analysis tasks.*"""

#c Missing values/impossible values

#missing value -
print(food_trucks.isnull())

"""*There isnt any missing values in this data . As seen when conducting the function from is.null()*"""

#impossible values
food_trucks2 =food_trucks[food_trucks["avg_cost_item"]>0]

food_trucks2.describe()

"""food_trucks2 =food_trucks[food_trucks["avg_cost_item"]>0] and food_trucks2.describe(), we are filtering out any rows in the food_trucks DataFrame where the avg_cost_item column has a value of 0 or less. This is because it is unlikely that a food truck would sell an item for free or at a negative price. By removing these impossible values, we can obtain more accurate and meaningful summary statistics of the avg_cost_item column, such as its mean and standard deviation, which can help us gain insights into the pricing strategy of food trucks.




"""

import pandas as pd
from scipy import stats

# Standardize the numerical variables
numerical_cols = ["avg_transaction_cost", "mnths_operational", "days_yr", "avg_cost_item", "number_trucks", "dist_lobland", "bev_percent"]
ven.loc[:, numerical_cols] = stats.zscore(ven.loc[:, numerical_cols])


foodtrucks_standardized = ven.copy()

# View the standardized dataset
print(foodtrucks_standardized.head())

"""*All the data nneds to be standardized because each variables are in different values .In this dataset, the variables have different units and scales. For example, the "avg_transaction_cost" variable ranges from 12.1 to 15.56, while the "days_yr" variable ranges from 124 to 186. Therefore, if the analysis involves comparing or combining these variables, standardization may be necessary to eliminate the effects of the different scales.*"""

#E elbow chart

import pandas as pd
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans

sse = []
for k in range(1, 11):
    kmeans = KMeans(n_clusters=k, n_init=10, random_state=48)
    kmeans.fit(foodtrucks_standardized)
    sse.append(kmeans.inertia_)

plt.plot(range(1, 11), sse)
plt.title('Elbow Chart')
plt.xlabel('Number of clusters')
plt.ylabel('SSE')
plt.show()

"""F-The number of clusters can be decided based on the point on the elbow plot where the rate of decrease in SSE starts to slow down significantly, indicating diminishing returns on adding more clusters. This point is called the "elbow point". Seen from the elbow chart , the elbow point is on 5 where we can see the diminishing returns. Not evidently seen but the slop is regressing more after 5

"""

# Build k-means model with 5 clusters
kmeans = KMeans(n_clusters=5, n_init=10, random_state=48)
kmeans.fit(foodtrucks_standardized)

# Get the cluster labels
cluster_labels = kmeans.labels_

# Add the cluster labels to the original dataframe
foodtrucks_standardized["cluster"] = kmeans.labels_

# Generate summary statistics for each cluster
cluster_summary = foodtrucks_standardized.groupby("cluster").mean()

# Display the summary statistics
print(cluster_summary)

"""*These clusters are groups of food trucks that have similar characteristics based on the variables used in the k-means clustering algorithm. Cluster 0 represents food trucks with high average cost item and low average transaction cost, while Cluster 1 represents food trucks with low average cost item and moderate average transaction cost. Cluster 2 represents food trucks with high bev_percent and moderate days_yr, while Cluster 3 represents food trucks with high dist_lobland and moderate number_trucks. Finally, Cluster 4 represents food trucks with high mnths_operational and moderate days_yr.*"""

sns.barplot(data=foodtrucks_standardized, x="cluster", y="number_trucks")

"""*This code generates a bar plot that shows the average number of trucks for each cluster. The x-axis represents the cluster labels, and the y-axis represents the average number of trucks in each cluster. The height of each bar indicates the average number of trucks in the corresponding cluster. The plot allows us to compare the number of trucks across different clusters and identify any significant differences. In this case, it appears that Cluster 1 has the highest average number of trucks, while Cluster 2 has the lowest average number of trucks.*"""

sns.boxplot(data=foodtrucks_standardized, x="cluster", y="bev_percent")

"""*This code creates a boxplot that displays the distribution of beverage sales percentages for each of the five clusters. The x-axis represents the cluster labels, and the y-axis represents the percentage of beverage sales. Each boxplot shows the median (the horizontal line inside the box), the interquartile range (the box), and the range of data (the whiskers). Outliers are also shown as individual points beyond the whiskers. This visualization can help identify any differences or similarities in the beverage sales percentage across the five clusters.*"""

import seaborn as sns

# create correlation matrix of standardized data
corr_matrix = foodtrucks_standardized.corr()

# plot heatmap of correlation matrix
sns.heatmap(corr_matrix, annot=True, cmap="coolwarm")

"""This code generates a heatmap using seaborn's heatmap function, with the correlation matrix of the standardized food truck data as input. The annot parameter is set to True, which displays the correlation coefficients in each cell of the heatmap, and the cmap parameter is set to "coolwarm", which uses a blue-to-red color map to indicate negative-to-positive correlations.

This visualization allows us to see which pairs of variables are highly correlated (either positively or negatively) and which are not. for example,there is a moderate negative correlation between the number of trucks and the average transaction cost. This suggests that as the number of trucks increases, the average transaction cost tends to decrease, which could be due to economies of scale or increased competition in the market.
"""

import seaborn as sns

sns.set_style("whitegrid")

sns.barplot(data=foodtrucks_standardized, x="cluster", y="avg_cost_item", ci=None)

"""This bar plot shows the differences in average cost per item between the 5 clusters of food trucks. The height of each bar represents the average cost per item for each cluster, and the error bars (not visible in this case because the ci parameter is set to None) would show the confidence interval for each average.

Cluster 1 has the lowest average cost per item, while cluster 0 has the highest. Cluster 3 and 4 have relatively similar average costs, while cluster 2 minimal average cost.

Suppose the mean and standard deviation of the original "average_cost_per_item" variable are $8 and $2, respectively. Then, for cluster 0, the standardized average cost per item is 0.72. To obtain the actual average cost per item for cluster 0, you would perform the following calculation:

Actual average cost per item for cluster 0 = (0.72 * $2) + $8 = $9.44

Similarly, for cluster 2, the standardized average cost per item is 1.98. To obtain the actual average cost per item for cluster 2, you would perform the following calculation:

Actual average cost per item for cluster 2 = (0,12 * $2) + $8 = $8.24

This information can be useful for food truck owners and operators to understand where they stand relative to their peers and competitors, and to make decisions about pricing and menu offerings based on this information. For example, if a food truck operator in cluster 1 is finding it difficult to attract customers, they may consider lowering their prices or adjusting their menu to make their offerings more appealing to potential customers. Conversely, a food truck operator in cluster 2 may consider raising their prices or adding more high-end menu items to appeal to customers who are willing to pay more.

#J -Question
clusters -0,1,2,3,4

0)High-cost, low-transaction vendors: This cluster has the highest average cost-per-item but the lowest average transaction cost. These vendors may be specialty food trucks that offer high-end, unique products that attract a smaller customer base willing to pay a premium. They may also be located in high-end areas with high rent prices.

1)Low-cost, high-transaction vendors: This cluster has the lowest average cost-per-item but the highest average transaction cost. These vendors may offer more affordable and accessible food options that appeal to a broader customer base, allowing them to generate more sales volume despite their lower prices. They may also be located in high-traffic areas such as busy city centers or popular event venues.

2)Remote vendors: This cluster has the highest distance from the central business district, suggesting that these vendors operate in more remote or less accessible areas. They may cater to customers who work or live in these areas and have limited food options, or they may target specific events or festivals that take place in these areas.

3)New vendors: This cluster has the lowest number of months operational, suggesting that these vendors are relatively new to the food truck business. They may be still in the process of establishing their brand or building a customer base, and may offer more unique or experimental food options to attract customers.

4)Niche vendors- has negative values for all variables except for the number of months operational and days per year. This suggests that these vendors have a lower than average cost per item but also have fewer trucks, serve a smaller geographic area, and may have a lower sales volume. Given the high value for months operational, it is possible that these vendors have a loyal customer base that supports their business. They may also have a unique selling point, such as a specialty food item, that attracts customers despite their smaller size. Overall, this cluster may represent small, niche vendors with a dedicated customer base.

#k- question
Lobster Land can benefit from this model in several ways. Firstly, it can help the company to identify different types of food truck vendors operating in the market and gain a better understanding of their strengths and weaknesses. This can be useful in developing strategies to compete with different vendors based on their strengths and weaknesses. For example, if Lobster Land identifies a high-cost, low-transaction vendor operating in the same area, it could target customers who are willing to pay a premium for high-end seafood offerings.

Secondly, this model can help Lobster Land to identify potential areas for expansion. For instance, if it identifies a cluster of remote vendors in an area where there is a lack of seafood options, it could explore the feasibility of setting up a food truck in that area to cater to customers who are not currently being served.

Finally, this model can also help Lobster Land to identify potential collaborations with other food truck vendors. For example, if it identifies a cluster of niche vendors with a loyal customer base, Lobster Land could potentially collaborate with them to offer unique seafood offerings that appeal to a broader customer base. Overall, by utilizing this model, Lobster Land can gain valuable insights into the food truck industry and develop strategies that can help it to grow and compete more effectively in the market.
"""

woodie_roller = pd.read_csv('woodie.csv')

woodie_roller.head(5)

"""#B

which elements are numerical and categorical -

bundleID: this variable represents a series of sequential integers from 1 to 288 and can be treated as a numeric identifier.

maxspeed: this variable represents the maximum speed reached by the roller coaster during the ride, and has numeric values of 40, 60, or 80 mph.

steepest_angle: this variable represents the number of degrees associated with the steepest drop on the ride and has numeric values of 50 or 75 degrees.

seats_car: this variable represents the number of seats in each car of the roller coaster, and can be treated as a numeric variable with values of 2 or 4.

drop: this variable represents the size of the largest vertical drop during the ride, and has numeric values of 100, 200, or 300 feet.

avg_rating: this variable represents the average rating that the bundle received on a score from 0 to 10 and can be treated as a numeric variable.

The following variable is categorical:

start_high: this variable has two categorical options, "Yes" or "No", representing whether the roller coaster starts at a high altitude or not.

track_color: this variable has four categorical options, "green", "blue", "white", and "red", representing the color of the roller coaster track.
"""

#C
#drop the bundleID variable
woodie_roller.drop('bundleID', axis=1, inplace=True)

woodie_roller['start_high'] = woodie_roller['start_high'].replace({'Yes': 1, 'No': 0})

# create dummy variables for all remaining categorical variables
woodie_roller = pd.get_dummies(woodie_roller, drop_first=True)

woodie_roller.head()

"""#C -A
Dummifying numeric variables is a way to convert them into categorical variables, which can be more useful for certain types of analysis, such as linear regression. In the case of linear regression, numerical variables can create issues related to multicollinearity, where two or more variables are highly correlated with each other, leading to unstable and unreliable estimates of the model coefficients. By converting the numeric variables into categories, we can avoid this problem and create a more robust and interpretable model. Additionally, dummifying numeric variables can also capture any nonlinear relationships that may exist between the variable and the outcome, which may not be captured by a linear model that treats the variable as continuous.
"""

from sklearn.linear_model import LinearRegression

#D
# define input and output variables
X = woodie_roller.drop('avg_rating', axis=1)
y = woodie_roller['avg_rating']

# create linear regression model and fit it to the data
model = LinearRegression()
model.fit(X, y)

#E
print("Model Coefficients:")
for i, col in enumerate(X.columns):
    print(f"{col}: {model.coef_[i]}")

"""Based on the linear model we have developed, we can see that the most significant predictor of a roller coaster's average rating is the maximum speed it reaches during the ride, as indicated by the positive coefficient of 0.037. Specifically, for every 1 mph increase in maximum speed, we can expect to see an increase in the average rating by approximately 0.037 points, holding all other variables constant. This indicates that Lobster Land may want to consider investing in roller coasters with higher maximum speeds to improve the overall experience for their guests.

Additionally, we can see that the steepest angle of the roller coaster's largest drop is also a significant predictor of the average rating, as indicated by the negative coefficient of -0.0207. For every 1 degree increase in the steepest angle, we can expect to see a decrease in the average rating by approximately 0.0207 points, holding all other variables constant. This suggests that Lobster Land may want to prioritize designing roller coasters with slightly less steep angles to improve the overall guest satisfaction.

Interestingly, the color of the roller coaster's track did not appear to have a significant impact on the average rating, as indicated by the relatively small and insignificant coefficients for the different track colors. This may indicate that guests are more focused on the actual ride experience rather than the visual aesthetics of the roller coaster. However, it is worth noting that this data is based on a limited set of colors, and additional research could be conducted to investigate the impact of a wider range of colors on the guest experience.

Finally, we can see that the other variables in our model, such as starting height, seat configuration, and drop size, did not have a significant impact on the average rating, as indicated by their relatively small and insignificant coefficients. While these variables may still be important considerations in the design and construction of roller coasters, they may not be as critical in determining the overall guest experience and satisfaction.

Overall, our model provides valuable insights into the factors that drive guest satisfaction with roller coasters at Lobster Land. By focusing on factors such as maximum speed and steepest angle, Lobster Land can make strategic investments in the design and construction of new roller coasters to enhance the overall guest experience and drive higher ratings and increased revenue.

**Part III: Wildcard: Marketing & Segments (1 point)**

The ad **"we will always need human connection. download bumble"** is targeting consumers who are seeking romantic relationships or connections with others. This is evident from the tagline, which highlights the need for human connection, and the call-to-action to download Bumble, which is a popular dating app. The segment being targeted likely includes young adults and millennials who are comfortable with using technology to meet new people and form connections.

I believe this ad is an undifferentiated (mass market) ad because it appeals to a broad range of consumers who may be looking for romantic connections, regardless of their specific demographics or interests. However, the placement of the ad on social media platforms like Instagram and Facebook may indicate that it is specifically targeting users of these platforms.

Anyone who is willling to enter romantic relationships are part of the segment and especially people from 18-30 would be the major target market compared to other ages. Being in that bracket and looking for one , I am part of it.

In terms of effectiveness, the ad does a good job of highlighting the need for human connection and positioning Bumble as a solution to this need. The tagline is relatable and taps into a basic human desire for connection, while the call-to-action is clear and straightforward. Overall, I think this ad is likely to be effective in attracting users to download the Bumble app and potentially form new connections.
"""

!pip install nbconvert

!jupyter nbconvert -- to html assignment2_aravindrao.ipynb

!jupyter nbconvert --to html assignment2.ipynb